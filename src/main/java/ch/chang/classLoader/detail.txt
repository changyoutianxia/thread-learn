
1、类的加载过程
    1、加载
            1、通过权限定名来获取二进制流
            2、把这个二进制流所代表的静态存储结构转化为方法区的运行时数据结构
            3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区的这个类的各种数据的访问入口
    2、链接
        1、验证：
                    确保加载类的正确性,比如类编译的版本号
        2、准备：
                    为类的静态变量分配内存，并且初始化。
                 比如
                    public static int i =1
                    先给i=0，在初始化阶段才会赋值i=1;
        3、解析：
                   把类中的符号引用转为直接引用

    3、初始化
         为类的静态变量赋予正确的初始值（将2.2中的i赋值为1）;

2、java程序对类的使用方式
    1、主动使用
            所有的java虚拟机实现必须在每个类或者接口被java程序首次主动使用时，才初始化他们。
            1、方式
                会初始化
                            1、  new
                            2、  对某个类或者接口静态变量的读写
                            3、  反射
                            4、  子类
                            5、  启动类（main）
                 不会初始化
                            1、   Object[] object = new Object[4]
                            2、  （子类引用父类静态变量，子类不会被初始化）
                            3、   final 修饰的常量（在编译阶段可以计算出来的会被放到常量池    ）
    2、被动使用

3、加载方式
    1、本地硬盘加载
    2、内存加载
    3、网络加载
    4、zip jar等归档文件中加载
    5、数据库
    6、动态编译
4、JVM 内存
        方法区：
                线程共享
                class 数据结构
                常量池
        堆
                线程共享
                Class对象也存储在这里
                对象
        虚拟机栈
                线程私有
                每个方法一个栈

        程序计数器
                记录下一次执行的位置
                线程私有
                    如果执行的是native方法 程序计数器会变为undefined
         本地方法栈
                c++

classLoader
            1、classLoader 加载二进制文件
            2、在堆中创建Class对象 这个对象作为程序访问方法去中的数据结构
            3、数据结构存储在方法区
            4、创建了一个对象
            5、栈中存储这个对象的引用
创建一个对象
    类的加载
            方式一
                   栈中的引用指向堆中句柄，这个句柄可以找到堆中的对象数据和方法区的数据结构
            方式二
                    栈中的引用，直接指向对象数据包含了方法区的数据结构
链接
        1、验证
                保证加载的二进制文件，保证不能损坏jvm
                 1、文件格式验证，
                    1、魔术因子是否正常class:0xCAFEBABE
                    2、主版本号是否符合当前虚拟机
                    3、常量池中的常量类型是不是不支持
                 2、元数据验证
                    1、是否有父类
                    2、父类是否允许继承
                    3、是否实现了抽象方法
                    4、是否覆盖了父类的final
                    ，，，，，
                 3、字节码验证
                    1、主要进行数据流和控制流验证，int类型给了一个long类型数据
                 4、符号验证
                    1、调用了一个不存在的方法
        2、准备
                  1、给类的变量赋值初始值
                            int             0
                            long            0L
                            short           0
                            byte            0
                            char            '\u0000'
                            float           0.0f
                            double          0.0d
                            reference       null
        3、解析
                   1、将符号引用转为直接引用
初始化
        1、执行<clinit>()方法，该方法由编译器自动收集类中的所有变量的赋值动作，和静态语句块中的语句合并产生的
        2、静态语句块只能访问定义在静态语句块之前的变量，之后的变量只能赋值不能访问。
        3、首先会执行父类的<clinit>()方法，然后在执行子类的
        4、<clinit> 虚拟机保证了线程安全


加载系统自定义类
            如果用自己写的java.lang.String 不会被系统加载，系统会检测

运行时包
            运行时包
                        是类的加载器命名空间+包的命名空间
                        父类加载器不可见子类加载器加载的类
                        类加载器之间不可见

类的卸载
            该类的所有实列被回收
            该类的ClassLoader被回收
            该类的Class对象没有任何地方被引用
            GC时机不可控，同样对Class的卸载也不可控